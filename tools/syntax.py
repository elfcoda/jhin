import os

split_str = "----------"
split_str1 = "::="
fin = "../src/syntax/syntax.txt"
# fout = "syntax.out"
# if not os.path.isfile(fout):
#     fd = open(fout, mode="w", encoding="utf-8")
#     fd.close()

origin_production = {}
gen_production = {}
all_production_replaced = {}

gen_note_count = 0
gen_note_pre = "GEN_TERMINAL_"
EPSILON = "EPSILON"
NOTE_QUES = "NOTE_QUES"
NOTE_STAR = "NOTE_STAR"
NOTE_PLUS = "NOTE_PLUS"
def gen_note_str():
    global gen_note_count
    gen_note_count += 1
    return gen_note_pre + str(gen_note_count)

def gen_star(str_production):
    global gen_production
    new_symbol = gen_note_str()
    gen_production[new_symbol] = [str_production + " " + new_symbol, EPSILON]
    return new_symbol

def gen_plus(str_production):
    global gen_production
    new_symbol = gen_note_str()
    gen_production[new_symbol] = [str_production + " " + new_symbol, str_production]
    return new_symbol

def gen_ques(str_production):
    global gen_production
    new_symbol = gen_note_str()
    gen_production[new_symbol] = [str_production, EPSILON]
    return new_symbol

def substitute_production(production, NOTE_KIND):
    while production.find(NOTE_KIND) != -1:
        idx1 = production.find(NOTE_KIND)
        idx2 = production.find("(", idx1)
        idx3 = production.find(")", idx1)
        if NOTE_KIND == NOTE_QUES:
            gen_func = gen_ques
        elif NOTE_KIND == NOTE_STAR:
            gen_func = gen_star
        elif NOTE_KIND == NOTE_PLUS:
            gen_func = gen_plus
        new_symbol = gen_func(production[idx2+1: idx3])
        s_replace = production[idx1: idx3+1]
        production = production.replace(s_replace, new_symbol, 1)

    return production

# handle NOTE_ macro
def expand_production(production):
    production = substitute_production(production, NOTE_QUES)
    production = substitute_production(production, NOTE_STAR)
    production = substitute_production(production, NOTE_PLUS)

    return production

list1 = ["!=", "<-", ">=", "=>", "<=", "==", "->",
        "(", ")", "{", "}", "[", "]", "*", "@", ":", ",", \
        "if", "while", ".", "+", "-", "/", "!", \
        "<", ">", "for", "return", "case", "of", "else", \
        "otherwise", "lambda", "isVoid", "'\\n'", "inherits", "class", "new", "let", "in"
        ]

list2 = ["NEQ", "ASSIGN", "GE", "INFER", "LE", "EQ", "ARROW",
        "LPAREN", "RPAREN", "LCURLY", "RCURLY", "LBRACK", "RBRACK", "STAR", "AT", "COLON", "COMMA", \
        "IF", "WHILE", "DOT", "PLUS", "MINUS", "SLASH", "NOT", \
        "LT", "GT", "FOR", "RETURN", "CASE", "OF", "ELSE", \
        "OTHERWISE", "LAMBDA", "ISVOID", "NEWLINE", "INHERITS", "CLASS", "NEW", "LET", "IN"
        ]

# replace "*" by STAR, and so on
def replace_production(production):
    global list1
    global list2

    for (l1, l2) in zip(list1, list2):
        production = production.replace(l1, l2)

    return production

def gen_token_string_to_symbol():
    global list1
    global list2

    s = ""
    cnt = 0
    for (l1, l2) in zip(list1, list2):
        s += "{\"" + l2 + "\", \"" + l1 + "\"}, "
        cnt += 1
        if (cnt % 10 == 0):
            s += "\n\t\t\t"

    return "\n\t\t\t" + s[: -2]



def show_production(production_dict):
    # format
    print("=================")
    for k, v in production_dict.items():
        for production in v:
            print(k + "\t ::= " + production)
    print("=================")

def gen_non_terminal_list():
    global origin_production
    global gen_production
    global all_production_replaced
    non_terminal_v = []
    # origin_production
    for k, v in origin_production.items():
        non_terminal_v.append(k)
        v_replaced = []
        for production in v:
            v_replaced.append(replace_production(production))
        all_production_replaced[k] = v_replaced

    # gen_production
    for k, v in gen_production.items():
        non_terminal_v.append(k)
        v_replaced = []
        for production in v:
            v_replaced.append(replace_production(production))
        all_production_replaced[k] = v_replaced
    return non_terminal_v

# generate non_terminal_file
non_terminal_file = "non_terminal.h"
def gen_cpp_code(non_terminal_to_id, id_to_non_terminal, non_ter_cnt_min, non_ter_cnt, all_production, token_string_to_symbol):
    s = "/* this file is generated by syntax.py, do not modify it */\n\n\n"
    s_define = "__" + non_terminal_file.upper().replace(".", "_") + "__"
    s += "#ifndef " + s_define + "\n"
    s += "#define " + s_define + "\n\n"
    s += "#include <unordered_map>\n"
    s += "#include <vector>\n"
    s += "#include <string>\n\n\n"
    s += "namespace jhin {\n"
    s += "namespace syntax {\n\n"
    s += "\t#define NON_TERMINAL_IDX_MIN    " + str(non_ter_cnt_min) + "\n"
    s += "\t#define NON_TERMINAL_IDX_MAX    " + str(non_ter_cnt) + "\n"
    s += "\t#define SYNTAX_EPSILON_STR      \"" + EPSILON + "\"\n"
    s += "\t#define SYNTAX_EPSILON_IDX      " + str(non_ter_cnt+1) + "\n\n"
    s += "\tstd::unordered_map<std::string, unsigned int> non_terminal_to_id = {" + non_terminal_to_id + "\n\t};\n\n"
    s += "\tstd::unordered_map<unsigned int, std::string> id_to_non_terminal = {" + id_to_non_terminal + "\n\t};\n\n\n"
    s += "\tstd::unordered_map<std::string, std::vector<std::vector<std::string>>> all_production = {" + all_production + "\n\t};\n\n"
    s += "\tstd::unordered_map<std::string, std::string> token_string_to_symbol = {" + token_string_to_symbol + "\n\t};\n\n"

    s += "};    /* namespace syntax */\n"
    s += "};    /* namespace jhin */\n\n\n"
    # end of file
    s += "#endif\n\n"
    with open("../src/syntax/" + non_terminal_file, "w") as non_ter_file:
        non_ter_file.write(s)


def gen_non_terminal_code(non_terminal_v):
    # non_terminal_to_id
    non_ter_str = ""
    id_to_non_terminal = ""
    non_ter_cnt = 0
    non_ter_cnt_min = non_ter_cnt + 1
    for item in non_terminal_v:
        non_ter_str += ", "
        id_to_non_terminal += ", "
        non_ter_cnt += 1
        if non_ter_cnt % 10 == 0:
            non_ter_str += "\n\t\t\t"
            id_to_non_terminal += "\n\t\t\t"
        non_ter_str += ("{\"" + item + "\", " + str(non_ter_cnt) + "}")
        id_to_non_terminal += ("{" + str(non_ter_cnt) + ", \"" + item + "\"}")
    non_ter_str = "\n\t\t\t" + non_ter_str[2:]
    id_to_non_terminal = "\n\t\t\t" + id_to_non_terminal[2:]

    # gen_all_production_cpp_map
    all_production = gen_all_production_cpp_map()

    # eg: "WHILE" -> "while", "PLUS" -> "+"
    token_string_to_symbol = gen_token_string_to_symbol()

    gen_cpp_code(non_ter_str, id_to_non_terminal, non_ter_cnt_min, non_ter_cnt, all_production, token_string_to_symbol)


def gen_all_production_cpp_map():
    global all_production_replaced
    s = ""
    for k, v in all_production_replaced.items():
        outer_vector = ""
        for vs in v:
            vss = vs.split()
            inner_vector = ""
            for vss_symbol in vss:
                inner_vector += ", \"" + vss_symbol.strip() + "\""
            inner_vector = ", {" + inner_vector[2: ] + "}"  # , {"STAR", "NOT"}
            outer_vector += inner_vector
        outer_vector = "{" + outer_vector[2: ] + "}"        # {{"STAR", "NOT"}, {"STAR", "NOT"}}
        s += ", \n\t\t\t{\"" + k + "\", " + outer_vector + "}"      # , {"k", {{"STAR", "NOT"}, {"STAR", "NOT"}}}, {"k", {{"STAR", "NOT"}, {"STAR", "NOT"}}}
    return s[2: ]


with open(fin, "r") as file_in:         # , open(fout, "w") as file_out:
    pre_process = ""
    for line in file_in.readlines():
        pre_process += line.split("#")[0]

    # print(pre_process)
    non_terminals = pre_process.split(split_str)
    non_terminals_len = len(non_terminals)
    for i in range(1, non_terminals_len):  # idx of valid non_terminals
        non_terminal_v = non_terminals[i].strip().split(split_str1)
        non_terminal = non_terminal_v[0].strip()
        productions_v = non_terminal_v[1].strip().split("|")
        productions = []
        for p in productions_v:
            productions.append(expand_production(p.strip()))
        origin_production[non_terminal] = productions
    # now we have non_terminal and productions in origin_production
    # and other productions in gen_production

    # show_production(origin_production)
    # show_production(gen_production)
    non_terminal_v = gen_non_terminal_list()
    show_production(all_production_replaced)
    gen_non_terminal_code(non_terminal_v)



