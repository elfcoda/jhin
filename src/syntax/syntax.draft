## LALR(DRAFT):  
-- lexer need to implement '\n' first(or not)
-- RE_VALUE: TypeName(Int String), ClassName(Animal)  
-- solution: union multi-newline
DEFINE EPSILON

NewLineStar ::= '\n' NewLineStar
            |   EPSILON
NewLinePlus ::= '\n' NewLinePlus
            |   '\n'

----------------------------------------------------------------------------------------------------------
### -- program  
Prog'   ::= Prog  
Prog    ::= (Class|Proc)*
  
----------------------------------------------------------------------------------------------------------
### -- elif may account for the complexity of code logic, so I remove the syntax. elif can be replaced by "recursive if-else" or "case of" syntax, return NoType?
Cmd     ::= CmdN  
        |   CmdC
        |   CmdU

### -- normal
CmdN    ::= RE_ID <- Exp
       
### -- curly if(while)-exp can recurse, by other if(while)-exp  
CmdC    ::= while (Exp) { Formals }  
        |   if (Exp) { Formals }  
        |   if (Exp) { Formals } else { Formals }
        
### -- uncurly. donot followed by if-exp and while-exp. in this case, recursive if-exp may lead to ambigious semantics, cannot recurse with other if(while)-exp  
CmdU    ::= while (Exp) FormalU  
        |   if (Exp) FormalU else FormalU   
        |   if (Exp) FormalU  
  
### -- Formal  
Formals ::= (Cmd|Exp|DeclN) *
FormalU ::= CmdN|Exp|DeclN  
  
  
----------------------------------------------------------------------------------------------------------
### -- Decl  
Decl    ::= DeclN  
        |   Class  
  
### -- DeclN  
DeclN   ::= RE_ID: Type
        |   RE_ID: Type <- Exp
        |   Proc  


### -- class  
Class   ::= class RE_VALUE { Decl * }  
        |   class RE_VALUE inherits RE_VALUE { Decl * }

### -- procedure  
-- multi-newline to one
Proc    ::= RE_ID([RE_ID: Type [, RE_ID: Type] * ])[: Type] { '\n' * (Exp|Cmd|DeclN) ('\n'+ (Exp|Cmd|DeclN)) *  '\n' * }  
        |   RE_ID([RE_ID: Type [, RE_ID: Type] * ])[: Type] { '\n' * }  


### -- Types  
Type    ::= ExpT|RE_ID|TYPE  
  
----------------------------------------------------------------------------------------------------------
  
### -- Exp, separate Exp by several sub-Exps, can be joint by '|', return value of multi-exp is the return value of the last exp  
Exp     ::= ExpV  
        |   ExpO  
        |   ExpB  
        |   ExpT  
        |   case Exp of {(RE_ID: Type => Exp '\n'|)* (otherwise => Exp)}  
        |   return Exp  
        |   let DeclN (, DeclN)* in Exp  
        |   RE_ID.RE_ID()                       -- call
        |   RE_ID@RE_VALUE.RE_ID()  
        |   (Exp).RE_ID()
        |   (Exp)@RE_VALUE.RE_ID()  -- for dispatching
        |   RE_ID()  
        |   RE_ID(Exp [, Exp] * )  
        |   RE_ID.RE_ID(Exp [, Exp] * )  
        |   RE_ID@RE_VALUE.RE_ID(Exp [, Exp] * )  
        |   (Exp).RE_ID(Exp [, Exp] * )  
        |   (Exp)@RE_VALUE.RE_ID(Exp [, Exp] * )  -- call
        |   lambda -> Exp  
        |   lambda DeclN [,DeclN] * -> Exp  

----------------------------------------------------------------------------------------------------------
  
### -- id can be a type, eg. m: TYPE = Int, or a value  
### -- Value exp  
ExpV    ::= Expv == ExpV1
        |   ExpV < ExpV1
        |   ExpV <= ExpV1  
        |   ExpV > ExpV1  
        |   ExpV >= ExpV1  
        |   Expv != ExpV1   -- Not Equal need implementing first  
        |   ExpV1

ExpV1   ::= ExpV1 + ExpV2  
        |   ExpV1 - ExpV2
        |   ExpV2

ExpV2   ::= ExpV2 * ExpV3  
        |   ExpV2 / ExpV3
        |   ExpV3

ExpV3   ::= ExpVN
        |   !ExpVN
        |   isVoid ExpVN
        |   new RE_VALUE  

ExpVN   ::= RE_INT  
        |   RE_DECIMAL  
        |   RE_STRING  
        |   RE_ID
        |   (ExpV)  

  
             
### -- Object exp  
ExpO    ::= THIS  
        |   (ExpO)
        |   RE_ID
  
### -- Bool exp  
ExpB    ::= TRUE  
        |   FALSE  
        |   !ExpB  
        |   (ExpB)
        |   RE_ID
  
### -- Type exp  
ExpT    ::= ExpT + ExpT1
        |   ExpT1

ExpT1   ::= ExpT1 * ExpT2
        |   ExpT2

ExpT2   ::= RE_VALUE    -- Type is a kind of value(ClassName)  
        |   OBJECT      -- supertype of any type  
        |   BOOL  
        |   INT  
        |   FLOAT  
        |   DOUBLE  
        |   LONG  
        |   STRING  
        |   UNIT  
        |   RE_ID
        |   (ExpT)

----------------------------------------------------------------------------------------------------------

